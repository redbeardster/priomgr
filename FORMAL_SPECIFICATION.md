# Формальная спецификация Priority Manager

## Обзор

Данная спецификация на TLA+ описывает поведение системы управления приоритетами процессов в реальном времени. Она позволяет формально проверить корректность алгоритмов адаптивной корректировки приоритетов.

## Основные компоненты модели

### Состояние системы

- **processes**: множество отслеживаемых процессов
- **priorities**: отображение процессов на их текущие приоритеты
- **system_load**: текущая нагрузка системы (0-100)
- **available_memory**: доступная память в MB
- **responsiveness**: время отклика системы в миллисекундах
- **adjustment_count**: счетчик выполненных корректировок

### Действия

1. **DiscoverProcess**: обнаружение нового процесса и установка начального приоритета
2. **TerminateProcess**: удаление завершенного процесса из мониторинга
3. **UpdateSystemState**: изменение параметров системы (нагрузка, память, отклик)
4. **AdjustPriorityByLoad**: снижение приоритета при высокой нагрузке CPU
5. **AdjustPriorityByResponsiveness**: снижение приоритета при плохом отклике
6. **AdjustPriorityByMemory**: снижение приоритета при нехватке памяти

## Проверяемые свойства

### Инварианты (Safety Properties)

#### 1. PrioritiesInBounds
```tla
∀ pid ∈ processes: MIN_PRIORITY ≤ priorities[pid] ≤ MAX_PRIORITY
```
Все приоритеты всегда находятся в допустимых границах [10, 95].

#### 2. ProcessCountBounded
```tla
|processes| ≤ MAX_PROCESSES
```
Количество отслеживаемых процессов не превышает максимум.

#### 3. MonotonicPriorityDecrease
```tla
(system_load > threshold ∨ responsiveness > 2000 ∨ memory < 100) ⇒
    □[∀ pid: priorities'[pid] ≤ priorities[pid]]
```
При проблемах с системой приоритеты не увеличиваются, только уменьшаются.

#### 4. NoSimultaneousPriorityIncrease
```tla
¬∃ pid1, pid2: (pid1 ≠ pid2 ∧ priorities'[pid1] > priorities[pid1] ∧ 
                priorities'[pid2] > priorities[pid2])
```
Невозможно одновременное повышение приоритетов нескольких процессов.

### Свойства живости (Liveness Properties)

#### 1. EventualPriorityReduction
```tla
(system_load > critical_threshold ∧ processes ≠ ∅) ⇝ 
    ∃ pid: priorities[pid] = MIN_PRIORITY
```
Если система перегружена, в конечном итоге хотя бы один процесс получит минимальный приоритет.

#### 2. EventualCleanup
```tla
∀ pid ∈ processes: (pid ∉ processes') ⇝ (pid ∉ DOMAIN priorities')
```
Завершенные процессы в конечном итоге удаляются из мониторинга.

#### 3. NoStarvation
```tla
□◇(system_load ≤ NUM_CPUS × CRITICAL_LOAD_MULT)
```
Система не застревает в состоянии постоянной перегрузки.

### Балансировка нагрузки

#### LoadBalancing
```tla
(system_load > critical ∧ |processes| > 1) ⇒ 
    ∃ pid: priorities[pid] ≤ MIN_PRIORITY + 20
```
При критической нагрузке хотя бы один процесс имеет относительно низкий приоритет.

## Ключевые теоремы

### Теорема 1: Безопасность приоритетов
**Утверждение**: При любой последовательности действий все приоритеты остаются в допустимых границах.

**Доказательство**: Индукция по длине трассы выполнения.
- База: Init устанавливает приоритеты в границах
- Шаг: Все действия используют max/min для ограничения значений

### Теорема 2: Отсутствие приоритетной инверсии
**Утверждение**: Система не создает ситуаций, где низкоприоритетный процесс блокирует высокоприоритетный.

**Обоснование**: Все корректировки монотонно уменьшают приоритеты при проблемах, что предотвращает инверсию.

### Теорема 3: Конечность корректировок
**Утверждение**: Для любого процесса количество корректировок приоритета конечно до достижения MIN_PRIORITY.

**Доказательство**: 
- Приоритет уменьшается на фиксированные значения (3, 5, 10)
- Диапазон конечен: MAX_PRIORITY - MIN_PRIORITY = 85
- Максимум корректировок: ⌈85/3⌉ = 29

### Теорема 4: Прогресс системы
**Утверждение**: Если система перегружена, она в конечном итоге снизит нагрузку через корректировку приоритетов.

**Обоснование**: Weak fairness гарантирует, что действия корректировки будут выполнены, что приведет к снижению нагрузки.

## Использование спецификации

### Запуск проверки модели

```bash
# Установка TLA+ Toolbox
# https://github.com/tlaplus/tlaplus/releases

# Проверка модели через командную строку
java -cp tla2tools.jar tlc2.TLC PriorityManager.tla -config PriorityManager.cfg

# Или использовать TLA+ Toolbox GUI
```

### Параметры для проверки

Можно варьировать константы для разных сценариев:

```
# Малая система
MAX_PROCESSES = 3
NUM_CPUS = 2

# Средняя система
MAX_PROCESSES = 5
NUM_CPUS = 4

# Большая система
MAX_PROCESSES = 10
NUM_CPUS = 8
```

## Обнаруженные проблемы и улучшения

### Потенциальные проблемы

1. **Отсутствие механизма восстановления приоритетов**: Текущая модель только снижает приоритеты, но не повышает их обратно при улучшении состояния системы.

2. **Возможность голодания**: Процесс может застрять на MIN_PRIORITY даже после нормализации нагрузки.

3. **Отсутствие приоритизации критичных процессов**: Все процессы корректируются одинаково.

### Рекомендуемые улучшения

1. Добавить действие `RestorePriority` для повышения приоритетов при нормализации:
```tla
RestorePriority(pid) ==
    /\ pid \in processes
    /\ system_load < NUM_CPUS
    /\ responsiveness < 1000
    /\ priorities[pid] < target_priority[pid]
    /\ priorities' = [priorities EXCEPT ![pid] = @ + 5]
```

2. Ввести классы приоритетов (critical, high, normal, low) с разными стратегиями корректировки.

3. Добавить гистерезис для предотвращения частых переключений.

## Связь с реализацией

Спецификация TLA+ соответствует следующим частям Rust-кода:

- `DiscoverProcess` → `discover_processes()`
- `AdjustPriority*` → `adjust_priorities_based_on_health()`
- `UpdateSystemState` → `check_system_health()`
- `TerminateProcess` → `cleanup_finished_processes()`

Инварианты проверяются через:
- `PrioritiesInBounds` → проверки в `calculate_optimal_priority()`
- `ProcessCountBounded` → условие в `discover_processes()`

## Заключение

Формальная спецификация позволяет:
- Проверить корректность алгоритмов до реализации
- Обнаружить граничные случаи и race conditions
- Документировать ожидаемое поведение системы
- Служить основой для тестирования

Модель может быть расширена для проверки более сложных сценариев, таких как взаимодействие с планировщиком ОС, обработка сигналов и координация между несколькими экземплярами менеджера.
