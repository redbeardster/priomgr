# Формальные свойства Priority Manager

## Категории свойств

### 1. Свойства безопасности (Safety Properties)
*"Ничего плохого не произойдет"*

#### S1: Ограниченность приоритетов
**Формально**: `∀t ∀p: MIN_PRIORITY ≤ priority(p,t) ≤ MAX_PRIORITY`

**На естественном языке**: В любой момент времени приоритет любого процесса находится в допустимом диапазоне [10, 95].

**Важность**: Предотвращает установку недопустимых значений, которые могут привести к отказу системного вызова или непредсказуемому поведению.

---

#### S2: Монотонность при стрессе
**Формально**: `(load > threshold) ⇒ ∀p: priority'(p) ≤ priority(p)`

**На естественном языке**: Когда система перегружена, приоритеты процессов не увеличиваются, только уменьшаются или остаются прежними.

**Важность**: Гарантирует, что система не усугубит проблему, повышая приоритеты при высокой нагрузке.

---

#### S3: Атомарность корректировки
**Формально**: `¬∃t ∃p₁,p₂: (p₁ ≠ p₂) ∧ adjusting(p₁,t) ∧ adjusting(p₂,t)`

**На естественном языке**: В каждый момент времени корректируется приоритет не более чем одного процесса.

**Важность**: Предотвращает race conditions и обеспечивает предсказуемое поведение.

---

#### S4: Сохранение конфигурации
**Формально**: `∀p ∀t: policy(p,t) = policy(p,0)`

**На естественном языке**: Политика планирования процесса (FIFO, RR, OTHER) не меняется после установки.

**Важность**: Гарантирует стабильность поведения процесса.

---

#### S5: Отсутствие приоритетной инверсии
**Формально**: `¬∃p₁,p₂,r: (priority(p₁) > priority(p₂)) ∧ holds(p₂,r) ∧ waits(p₁,r)`

**На естественном языке**: Низкоприоритетный процесс не может заблокировать высокоприоритетный через удержание ресурса.

**Важность**: Критично для систем реального времени.

---

### 2. Свойства живости (Liveness Properties)
*"Что-то хорошее в конечном итоге произойдет"*

#### L1: Конечная корректировка
**Формально**: `(load > threshold) ⇝ ∃p: priority(p) = MIN_PRIORITY`

**На естественном языке**: Если система перегружена, в конечном итоге хотя бы один процесс получит минимальный приоритет.

**Важность**: Гарантирует, что система реагирует на перегрузку.

---

#### L2: Очистка завершенных процессов
**Формально**: `∀p: terminated(p) ⇝ ¬monitored(p)`

**На естественном языке**: Каждый завершенный процесс в конечном итоге удаляется из мониторинга.

**Важность**: Предотвращает утечку памяти и накопление мертвых записей.

---

#### L3: Отсутствие голодания системы
**Формально**: `□◇(load ≤ NUM_CPUS × CRITICAL_MULT)`

**На естественном языке**: Система не застревает в состоянии постоянной перегрузки навсегда.

**Важность**: Гарантирует, что система может восстановиться.

---

#### L4: Обнаружение новых процессов
**Формально**: `∀p: matches(p) ⇝ monitored(p)`

**На естественном языке**: Каждый процесс, соответствующий паттерну, в конечном итоге будет обнаружен и добавлен в мониторинг.

**Важность**: Гарантирует полноту мониторинга.

---

### 3. Свойства справедливости (Fairness Properties)

#### F1: Слабая справедливость корректировки
**Формально**: `WF(AdjustPriority)`

**На естественном языке**: Если корректировка приоритета постоянно возможна, она в конечном итоге произойдет.

**Важность**: Предотвращает игнорирование перегрузки.

---

#### F2: Равномерная корректировка
**Формально**: `∀p₁,p₂: (adjustments(p₁) - adjustments(p₂)) ≤ K`

**На естественном языке**: Разница в количестве корректировок между любыми двумя процессами ограничена константой K.

**Важность**: Предотвращает несправедливое снижение приоритета одних процессов относительно других.

---

### 4. Временные свойства (Temporal Properties)

#### T1: Ограниченное время реакции
**Формально**: `(load > threshold) ⇒ ◇≤Δt (∃p: priority'(p) < priority(p))`

**На естественном языке**: При перегрузке система реагирует снижением приоритета в течение времени Δt.

**Важность**: Гарантирует своевременную реакцию на проблемы.

---

#### T2: Периодичность проверки
**Формально**: `□(check_time(t) ⇒ ◇≤interval check_time(t'))`

**На естественном языке**: Проверка состояния системы происходит с периодом не более interval.

**Важность**: Обеспечивает регулярный мониторинг.

---

### 5. Свойства производительности (Performance Properties)

#### P1: Ограниченность корректировок
**Формально**: `∀p: adjustments(p) ≤ ⌈(MAX_PRIORITY - MIN_PRIORITY) / min_step⌉`

**На естественном языке**: Количество корректировок для процесса ограничено сверху.

**Важность**: Гарантирует конечность процесса снижения приоритета.

---

#### P2: Минимальная частота корректировок
**Формально**: `∀p ∀t₁,t₂: (adjust(p,t₁) ∧ adjust(p,t₂)) ⇒ |t₂ - t₁| ≥ min_interval`

**На естественном языке**: Между двумя корректировками одного процесса проходит минимальное время.

**Важность**: Предотвращает чрезмерную нагрузку от частых системных вызовов.

---

### 6. Композиционные свойства (Compositional Properties)

#### C1: Независимость процессов
**Формально**: `∀p₁,p₂: adjust(p₁) ⊥ adjust(p₂)`

**На естественном языке**: Корректировка приоритета одного процесса не влияет на корректировку другого.

**Важность**: Упрощает рассуждения о системе и параллельное выполнение.

---

#### C2: Модульность политик
**Формально**: `∀policy: behavior(system) = ⋃ behavior(policy)`

**На естественном языке**: Поведение системы является композицией поведений отдельных политик.

**Важность**: Позволяет добавлять новые политики без изменения существующих.

---

## Формальные доказательства

### Теорема 1: Корректность границ

**Утверждение**: `Init ∧ □[Next]_vars ⇒ □PrioritiesInBounds`

**Доказательство** (индукция по длине трассы):

*База*: `Init ⇒ PrioritiesInBounds`
- В Init все приоритеты устанавливаются в допустимых границах

*Шаг*: `PrioritiesInBounds ∧ [Next]_vars ⇒ PrioritiesInBounds'`
- Рассмотрим каждое действие:
  - DiscoverProcess: устанавливает priority ∈ [MIN, MAX]
  - AdjustPriority: использует max(new_priority, MIN) и min(new_priority, MAX)
  - TerminateProcess: не изменяет приоритеты
  - UpdateSystemState: не изменяет приоритеты

∴ `□PrioritiesInBounds` ∎

---

### Теорема 2: Конечность снижения

**Утверждение**: `∀p: adjustments(p) ≤ ⌈(MAX_PRIORITY - MIN_PRIORITY) / 3⌉`

**Доказательство**:
- Минимальный шаг снижения: 3 (AdjustPriorityByMemory)
- Максимальный диапазон: MAX_PRIORITY - MIN_PRIORITY = 85
- Максимум шагов: ⌈85/3⌉ = 29

После 29 корректировок: priority ≤ MIN_PRIORITY
Дальнейшие корректировки невозможны (guard не выполняется) ∎

---

### Теорема 3: Отсутствие дедлока

**Утверждение**: `□◇Enabled(Next)`

**Доказательство**:
- UpdateSystemState всегда enabled (нет предусловий)
- ∴ хотя бы одно действие всегда доступно
- ∴ система не может застрять ∎

---

### Теорема 4: Реактивность

**Утверждение**: `(load > threshold) ∧ WF_vars(AdjustPriority) ⇝ (∃p: priority(p) = MIN_PRIORITY)`

**Доказательство**:
- Предположим load > threshold постоянно
- По WF, AdjustPriority в конечном итоге выполнится
- По Теореме 2, после конечного числа шагов priority(p) = MIN_PRIORITY
- ∴ свойство выполняется ∎

---

## Практическое применение

### Тестирование на основе свойств

```rust
#[cfg(test)]
mod property_tests {
    use proptest::prelude::*;
    
    // S1: Ограниченность приоритетов
    proptest! {
        #[test]
        fn priority_always_in_bounds(
            initial_priority in 10..=95,
            load in 0..100,
            memory in 0..16384
        ) {
            let adjusted = calculate_priority(initial_priority, load, memory);
            prop_assert!(adjusted >= 10 && adjusted <= 95);
        }
    }
    
    // S2: Монотонность при стрессе
    proptest! {
        #[test]
        fn priority_decreases_under_load(
            initial_priority in 10..=95,
            high_load in 50..100
        ) {
            let adjusted = adjust_for_load(initial_priority, high_load);
            prop_assert!(adjusted <= initial_priority);
        }
    }
}
```

### Мониторинг инвариантов в runtime

```rust
fn assert_invariants(&self) {
    // S1: Проверка границ
    for (pid, process) in self.monitored.iter() {
        assert!(
            process.current_priority >= MIN_PRIORITY &&
            process.current_priority <= MAX_PRIORITY,
            "Priority out of bounds for PID {}", pid
        );
    }
    
    // S4: Проверка политики
    for process in self.monitored.values() {
        assert_eq!(
            process.config.policy,
            self.get_current_policy(process.pid),
            "Policy changed for PID {}", process.pid
        );
    }
}
```

---

## Заключение

Эти формальные свойства:
1. Документируют ожидаемое поведение системы
2. Служат основой для верификации через TLA+
3. Направляют разработку тестов
4. Помогают обнаружить граничные случаи
5. Обеспечивают уверенность в корректности

Формальная верификация дополняет, но не заменяет тестирование и code review.
